---
title: "Upload de Mídia"
api: "POST /media/upload"
description: "Faz upload de arquivos de mídia para uso em campanhas e automações"
---

<Tip>
Os arquivos são enviados para o MinIO (armazenamento de objetos) e retornam uma URL permanente para uso nas mensagens.
</Tip>

## Tipos de Mídia Suportados

### Imagens
- JPEG/JPG (`.jpg`, `.jpeg`)
- PNG (`.png`)
- GIF (`.gif`)
- WebP (`.webp`)
- MIME types: `image/*`

### Vídeos
- MP4 (`.mp4`)
- AVI (`.avi`)
- MOV (`.mov`)
- MKV (`.mkv`)
- MIME types: `video/*`

### Áudios
- MP3 (`.mp3`)
- WAV (`.wav`)
- OGG (`.ogg`)
- M4A (`.m4a`)
- AAC (`.aac`)
- MIME types: `audio/*`

### Documentos
- PDF (`.pdf`)
- DOC/DOCX (`.doc`, `.docx`)
- XLS/XLSX (`.xls`, `.xlsx`)
- MIME types específicos aceitos

## Headers

<ParamField header="X-Access-Token" type="string" required>
  Token de acesso da empresa
</ParamField>

<ParamField header="Content-Type" type="string" required>
  Deve ser `multipart/form-data` (geralmente configurado automaticamente)
</ParamField>

## Body (Form Data)

<ParamField body="file" type="file" required>
  Arquivo a ser enviado (campo do formulário)
</ParamField>

<RequestExample>

```bash cURL
curl -X POST https://api.disparador.com/media/upload \
  -H "X-Access-Token: seu-access-token" \
  -F "file=@/caminho/para/arquivo.jpg"
```

```javascript JavaScript
// Upload simples
async function uploadMedia(file, accessToken) {
  const formData = new FormData();
  formData.append('file', file);
  
  const response = await fetch('https://api.disparador.com/media/upload', {
    method: 'POST',
    headers: {
      'X-Access-Token': accessToken
    },
    body: formData
  });
  
  if (!response.ok) {
    throw new Error(`Upload falhou: ${response.status}`);
  }
  
  const result = await response.json();
  console.log('URL da mídia:', result.url);
  return result;
}

// Exemplo com input de arquivo
const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    try {
      const result = await uploadMedia(file, 'seu-access-token');
      console.log('Upload concluído:', result);
    } catch (error) {
      console.error('Erro no upload:', error);
    }
  }
});
```

```python Python
import requests

def upload_media(file_path, access_token):
    url = "https://api.disparador.com/media/upload"
    headers = {
        "X-Access-Token": access_token
    }
    
    with open(file_path, 'rb') as file:
        files = {'file': file}
        response = requests.post(url, headers=headers, files=files)
    
    if response.status_code != 200:
        raise Exception(f"Upload falhou: {response.status_code}")
    
    return response.json()

# Exemplo de uso
try:
    result = upload_media('/caminho/para/imagem.jpg', 'seu-access-token')
    print(f"URL da mídia: {result['url']}")
    print(f"Nome no bucket: {result['objectName']}")
except Exception as e:
    print(f"Erro: {e}")
```

```php PHP
<?php
function uploadMedia($filePath, $accessToken) {
    $ch = curl_init();
    
    $cfile = new CURLFile($filePath);
    $data = array('file' => $cfile);
    
    curl_setopt($ch, CURLOPT_URL, "https://api.disparador.com/media/upload");
    curl_setopt($ch, CURLOPT_POST, 1);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'X-Access-Token: ' . $accessToken
    ]);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);
    
    if ($httpCode !== 200) {
        throw new Exception("Upload falhou: HTTP $httpCode");
    }
    
    return json_decode($response, true);
}

// Exemplo
try {
    $result = uploadMedia('/caminho/para/video.mp4', 'seu-access-token');
    echo "URL: " . $result['url'] . "\n";
    echo "Bucket: " . $result['bucket'] . "\n";
} catch (Exception $e) {
    echo "Erro: " . $e->getMessage();
}
?>
```

</RequestExample>

## Response

<ResponseField name="url" type="string">
  URL pública permanente do arquivo no MinIO
</ResponseField>

<ResponseField name="filename" type="string">
  Nome original do arquivo
</ResponseField>

<ResponseField name="size" type="number">
  Tamanho do arquivo em bytes
</ResponseField>

<ResponseField name="type" type="string">
  Tipo MIME do arquivo
</ResponseField>

<ResponseField name="bucket" type="string">
  Nome do bucket no MinIO onde o arquivo foi armazenado
</ResponseField>

<ResponseField name="objectName" type="string">
  Nome do objeto no MinIO (caminho interno)
</ResponseField>

<ResponseExample>

```json 200 - Sucesso
{
  "url": "https://minio.disparador.com/company-123/media/2024/01/abc123def456-imagem.jpg",
  "filename": "imagem-produto.jpg",
  "size": 2458624,
  "type": "image/jpeg",
  "bucket": "company-123",
  "objectName": "media/2024/01/abc123def456-imagem.jpg"
}
```

```json 400 - Arquivo Vazio
{
  "error": "Arquivo vazio"
}
```

```json 400 - Tipo Não Suportado
{
  "error": "Tipo de arquivo não suportado"
}
```

```json 401 - Token Inválido
{
  "error": "Token inválido ou expirado"
}
```

```json 500 - Erro no Upload
{
  "error": "Erro ao fazer upload do arquivo: [detalhes]"
}
```

</ResponseExample>

## Upload com Progresso

```javascript
function uploadWithProgress(file, accessToken, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    formData.append('file', file);
    
    // Monitorar progresso
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        onProgress(percentComplete);
      }
    });
    
    // Manipular resposta
    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(`Upload falhou: ${xhr.status}`));
      }
    });
    
    xhr.addEventListener('error', () => {
      reject(new Error('Erro de rede no upload'));
    });
    
    xhr.open('POST', 'https://api.disparador.com/media/upload');
    xhr.setRequestHeader('X-Access-Token', accessToken);
    xhr.send(formData);
  });
}

// Uso
const progressBar = document.getElementById('progress');

uploadWithProgress(file, 'seu-token', (progress) => {
  console.log(`Upload: ${progress.toFixed(0)}%`);
  progressBar.style.width = `${progress}%`;
}).then(result => {
  console.log('Upload completo:', result);
}).catch(error => {
  console.error('Erro:', error);
});
```

## Validação Prévia

```javascript
function validateFile(file) {
  const MAX_SIZE = 100 * 1024 * 1024; // 100MB
  
  // Validações básicas
  const validations = {
    size: {
      valid: file.size <= MAX_SIZE,
      message: `Arquivo muito grande (máximo ${MAX_SIZE / 1024 / 1024}MB)`
    },
    type: {
      valid: isValidFileType(file.type),
      message: 'Tipo de arquivo não suportado'
    }
  };
  
  // Verificar todas as validações
  for (const [key, validation] of Object.entries(validations)) {
    if (!validation.valid) {
      throw new Error(validation.message);
    }
  }
  
  return true;
}

function isValidFileType(mimeType) {
  const allowedTypes = [
    'image/', 'video/', 'audio/',
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  ];
  
  return allowedTypes.some(type => mimeType.startsWith(type) || mimeType === type);
}

// Uso
try {
  validateFile(file);
  const result = await uploadMedia(file, accessToken);
} catch (error) {
  alert(error.message);
}
```

## Upload em Lote

```javascript
async function uploadMultipleFiles(files, accessToken) {
  const results = [];
  const errors = [];
  
  // Upload sequencial para evitar sobrecarga
  for (const file of files) {
    try {
      console.log(`Enviando ${file.name}...`);
      const result = await uploadMedia(file, accessToken);
      results.push({
        file: file.name,
        success: true,
        url: result.url
      });
    } catch (error) {
      errors.push({
        file: file.name,
        success: false,
        error: error.message
      });
    }
  }
  
  return { results, errors };
}

// Uso
const files = Array.from(document.getElementById('files').files);
const { results, errors } = await uploadMultipleFiles(files, 'seu-token');

console.log(`Sucesso: ${results.length}`);
console.log(`Erros: ${errors.length}`);
```

## Integração com Campanhas

```javascript
// Fazer upload e criar campanha com a mídia
async function createCampaignWithMedia(campaignData, mediaFile, accessToken) {
  // 1. Upload da mídia
  const mediaResult = await uploadMedia(mediaFile, accessToken);
  
  // 2. Determinar tipo de mídia
  const mediaType = mediaResult.type.split('/')[0]; // image, video, audio
  
  // 3. Criar campanha com a URL da mídia
  const campaign = {
    ...campaignData,
    mediaUrl: mediaResult.url,
    mediaType: mediaType,
    fileName: mediaResult.filename
  };
  
  const response = await fetch('https://api.disparador.com/api/campaigns', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Access-Token': accessToken
    },
    body: JSON.stringify(campaign)
  });
  
  return response.json();
}
```

## Observações

<Note>
**Armazenamento MinIO:**
- Os arquivos são armazenados no MinIO (S3-compatible)
- URLs são permanentes e públicas
- Organização automática por empresa e data
- Nomes de arquivo são únicos (UUID + nome original)
</Note>

<Warning>
**Limites e Segurança:**
- Validação de tipo MIME no servidor
- Arquivos são organizados por empresa (isolamento)
- Considere implementar limites de quota por empresa
- URLs públicas - não envie arquivos sensíveis
</Warning>

## Compatibilidade

<Note>
O endpoint `/media/files/{filename}` ainda existe para compatibilidade com arquivos antigos armazenados localmente. Novos uploads são direcionados ao MinIO.
</Note>